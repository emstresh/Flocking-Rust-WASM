(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "../pkg/flocking_sim.js":
/*!******************************!*\
  !*** ../pkg/flocking_sim.js ***!
  \******************************/
/*! exports provided: Universe, __wbg_random_624219ee110d74d6, __wbindgen_throw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Universe\", function() { return Universe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_random_624219ee110d74d6\", function() { return __wbg_random_624219ee110d74d6; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_throw\", function() { return __wbindgen_throw; });\n/* harmony import */ var _flocking_sim_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./flocking_sim_bg.wasm */ \"../pkg/flocking_sim_bg.wasm\");\n\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? __webpack_require__(/*! util */ \"./node_modules/util/util.js\").TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== _flocking_sim_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer) {\n        cachegetUint8Memory0 = new Uint8Array(_flocking_sim_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction notDefined(what) { return () => { throw new Error(`${what} is not defined`); }; }\n/**\n*/\nclass Universe {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Universe.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _flocking_sim_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_universe_free\"](ptr);\n    }\n    /**\n    * @param {number} dimension\n    * @param {number} num_chunks\n    * @param {number} num_boids\n    * @returns {Universe}\n    */\n    static new(dimension, num_chunks, num_boids) {\n        var ret = _flocking_sim_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"universe_new\"](dimension, num_chunks, num_boids);\n        return Universe.__wrap(ret);\n    }\n    /**\n    * @param {number} delta\n    */\n    tick(delta) {\n        _flocking_sim_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"universe_tick\"](this.ptr, delta);\n    }\n    /**\n    * @returns {number}\n    */\n    num_boids() {\n        var ret = _flocking_sim_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"universe_num_boids\"](this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    boid_colors() {\n        var ret = _flocking_sim_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"universe_boid_colors\"](this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} val\n    */\n    set_k_obstacle_avoidance(val) {\n        _flocking_sim_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"universe_set_k_obstacle_avoidance\"](this.ptr, val);\n    }\n    /**\n    * @param {number} val\n    */\n    set_k_velocity_matching(val) {\n        _flocking_sim_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"universe_set_k_velocity_matching\"](this.ptr, val);\n    }\n    /**\n    * @param {number} val\n    */\n    set_k_boid_avoidance(val) {\n        _flocking_sim_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"universe_set_k_boid_avoidance\"](this.ptr, val);\n    }\n    /**\n    * @param {number} val\n    */\n    set_boid_max_vel(val) {\n        _flocking_sim_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"universe_set_boid_max_vel\"](this.ptr, val);\n    }\n    /**\n    * @returns {number}\n    */\n    boid_triangles() {\n        var ret = _flocking_sim_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"universe_boid_triangles\"](this.ptr);\n        return ret;\n    }\n}\n\nconst __wbg_random_624219ee110d74d6 = typeof Math.random == 'function' ? Math.random : notDefined('Math.random');\n\nconst __wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n\n\n//# sourceURL=webpack:///../pkg/flocking_sim.js?");

/***/ }),

/***/ "../pkg/flocking_sim_bg.wasm":
/*!***********************************!*\
  !*** ../pkg/flocking_sim_bg.wasm ***!
  \***********************************/
/*! exports provided: memory, __wbg_universe_free, universe_new, universe_tick, universe_num_boids, universe_boid_colors, universe_set_k_obstacle_avoidance, universe_set_k_velocity_matching, universe_set_k_boid_avoidance, universe_set_boid_max_vel, universe_boid_triangles */
/***/ (function(module, exports, __webpack_require__) {

eval("\"use strict\";\n// Instantiate WebAssembly module\nvar wasmExports = __webpack_require__.w[module.i];\n__webpack_require__.r(exports);\n// export exports from WebAssembly module\nfor(var name in wasmExports) if(name != \"__webpack_init__\") exports[name] = wasmExports[name];\n// exec imports from WebAssembly module (for esm order)\n/* harmony import */ var m0 = __webpack_require__(/*! ./flocking_sim.js */ \"../pkg/flocking_sim.js\");\n\n\n// exec wasm module\nwasmExports[\"__webpack_init__\"]()\n\n//# sourceURL=webpack:///../pkg/flocking_sim_bg.wasm?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var flocking_sim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flocking-sim */ \"../pkg/flocking_sim.js\");\n/* harmony import */ var flocking_sim_flocking_sim_bg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flocking-sim/flocking_sim_bg */ \"../pkg/flocking_sim_bg.wasm\");\n/* harmony import */ var _js_stats__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./js/stats */ \"./js/stats.js\");\n\n\n\n\n\nconst canvas = document.getElementById(\"c\");\ncanvas.width = window.innerWidth;\ncanvas.height = window.innerHeight;\n\nconst gl = canvas.getContext(\"webgl\");\nif (!gl) {\n    throw new Error(\"no webgl for you\");\n}\n\nconst universe = flocking_sim__WEBPACK_IMPORTED_MODULE_0__[\"Universe\"].new(500, 100, 1000);\n\nconst program = createProgramFromScripts(gl, [\"3d-vertex-shader\", \"3d-fragment-shader\"]);\n\nconst a_position = gl.getAttribLocation(program, \"a_position\");\nconst a_color = gl.getAttribLocation(program, \"a_color\");\n\nconst u_matrix = gl.getUniformLocation(program, \"u_matrix\");\n\nconst fovRadians = degToRad(60);\nlet cameraAngleRadians = degToRad(0);\nconst cameraTarget = [0, 0, 0];\nconst up = [0, 1, 0];\n\ndrawScene();\n\nfunction drawScene() {\n  const numBoids = universe.num_boids();\n  const positionsPtr = universe.boid_triangles();\n  const positions = new Float32Array(flocking_sim_flocking_sim_bg__WEBPACK_IMPORTED_MODULE_1__[\"memory\"].buffer, positionsPtr, numBoids * 3 * 3);\n  const colorsPtr = universe.boid_colors();\n  const colors = new Uint8Array(flocking_sim_flocking_sim_bg__WEBPACK_IMPORTED_MODULE_1__[\"memory\"].buffer, colorsPtr, numBoids * 4);\n\n  resize(gl);\n\n  // tell webgl how to convert from clip space to pixels\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n  // clear the canvas and the depth buffer\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n  // enable back face culling\n  // gl.enable(gl.CULL_FACE);\n\n  // enable depth test\n  gl.enable(gl.DEPTH_TEST);\n\n  // tell it to use our program (pair of shaders)\n  gl.useProgram(program);\n\n  // create a buffer for our geometry vertex positions\n  const positionBuffer = gl.createBuffer();\n  // bind the position buffer\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n  // put geometry data into buffer\n  gl.bufferData(\n    gl.ARRAY_BUFFER,\n    positions,\n    gl.STATIC_DRAW\n  );\n\n  const colorBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n  gl.bufferData(\n    gl.ARRAY_BUFFER,\n    colors,\n    gl.STATIC_DRAW\n  );\n\n  // turn on the attribute\n  gl.enableVertexAttribArray(a_position);\n\n  // bind the position buffer\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n  // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\n  let size = 3;          // 3 components per iteration\n  let type = gl.FLOAT;   // the data is 32bit floats\n  let normalize = false; // don't normalize the data\n  let stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position\n  let offset = 0;        // start at the beginning of the buffer\n  gl.vertexAttribPointer(a_position, size, type, normalize, stride, offset);\n\n  // turn on the attribute\n  gl.enableVertexAttribArray(a_color);\n\n  // bind the position buffer\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n\n  // Tell the attribute how to get data out of colorBuffer (ARRAY_BUFFER)\n  size = 3;                 // 3 components per iteration\n  type = gl.UNSIGNED_BYTE;  // the data is 8bit unsigned values\n  normalize = true;         // normalize the data (convert from 0-255 to 0-1)\n  stride = 0;               // 0 = move forward size * sizeof(type) each iteration to get the next position\n  offset = 0;               // start at the beginning of the buffer\n  gl.vertexAttribPointer(a_color, size, type, normalize, stride, offset);\n\n  // compute the projection matrix\n  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\n  const zNear = 1.0;\n  const zFar = 2000.0;\n  let projectionMatrix = m4.perspective(fovRadians, aspect, zNear, zFar);\n\n  // compute a matrix for the camera\n  const radius = 250;\n  let cameraMatrix = m4.yRotation(cameraAngleRadians);\n  cameraMatrix = m4.translate(cameraMatrix, 0, 0, radius * 1.5);\n\n  const cameraPosition = [\n    cameraMatrix[12],\n    cameraMatrix[13],\n    cameraMatrix[14]\n  ];\n\n  cameraMatrix = m4.lookAt(cameraPosition, cameraTarget, up);\n\n  // make a view matrix\n  let viewMatrix = m4.inverse(cameraMatrix);\n\n  // view projection matrix\n  let viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);\n\n  let matrix = viewProjectionMatrix; // m4.translate(viewProjectionMatrix, 0, 0, 0);\n\n  // let matrix = m4.perspective(fovRadians, aspect, zNear, zFar);\n  // matrix = m4.translate(matrix, translation[0], translation[1], translation[2]);\n\n  // set the matrix\n  gl.uniformMatrix4fv(u_matrix, false, matrix);\n\n  // draw the boids\n  const primitiveType = gl.TRIANGLES;\n  const geoOffset = 0;\n  const count = universe.num_boids();\n  gl.drawArrays(primitiveType, geoOffset, count);\n\n  // draw the bounds\n  // gl.drawArrays(gl.LINES, 0, 12);\n}\n\nlet then = 0;\nconst renderLoop = (now) => {\n  _js_stats__WEBPACK_IMPORTED_MODULE_2__[\"fps\"].render();\n  now *= 0.001; // convert from ms to sec\n  let delta = now - then;\n  then = now;\n\n  universe.tick(delta);\n\n  // cameraAngleRadians += delta;\n  // cameraAngleRadians %= 360;\n\n  drawScene();\n\n  requestAnimationFrame(renderLoop);\n};\n\nrequestAnimationFrame(renderLoop);\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./js/stats.js":
/*!*********************!*\
  !*** ./js/stats.js ***!
  \*********************/
/*! exports provided: fps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fps\", function() { return fps; });\nconst fps = new class {\n  constructor() {\n    this.fps = document.getElementById(\"fps\");\n    this.frames = [];\n    this.lastFrameTimeStamp = performance.now();\n  }\n\n  render() {\n    const now = performance.now();\n    const delta = now - this.lastFrameTimeStamp;\n    this.lastFrameTimeStamp = now;\n    const fps = 1 / delta * 1000;\n\n    this.frames.push(fps);\n    if (this.frames.length > 100) {\n      this.frames.shift();\n    }\n\n    let min = Infinity;\n    let max = -Infinity;\n    let sum = 0;\n    for (let i = 0; i < this.frames.length; i++) {\n      sum += this.frames[i];\n      min = Math.min(this.frames[i], min);\n      max = Math.max(this.frames[i], max);\n    }\n    let mean = sum / this.frames.length;\n\n    this.fps.textContent = `\nFrames per Second:\n         latest = ${Math.round(fps)}\navg of last 100 = ${Math.round(mean)}\nmin of last 100 = ${Math.round(min)}\nmax of last 100 = ${Math.round(max)}\n`.trim();\n  }\n}\n\n\n\n//# sourceURL=webpack:///./js/stats.js?");

/***/ })

}]);